package info.archinnov.achilles.generated;

import com.datastax.driver.core.querybuilder.QueryBuilder;
import com.datastax.driver.core.querybuilder.Select;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.Clust_UDT;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.Cols;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.Cols.Clust_UDT;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.Cols.Udt_UDT;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.ColsTM;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.ColsTM.Clust_UDT;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.ColsTM.Udt_UDT;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.E;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.E_TM;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.F;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.F_TM;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.Udt_UDT;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_Clust;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_Clust.Relation;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_Id;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_Id.Relation;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_Id.Token;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_TM_Clust;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_TM_Clust.Relation;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_TM_Id;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_TM_Id.Relation;
import info.archinnov.achilles.generated.dsl.TestEntityWithUDTAsClustering_Select.W_TM_Id.Token;
import info.archinnov.achilles.generated.meta.entity.TestEntityWithUDTAsClustering_AchillesMeta;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelect;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectColumns;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectColumnsTypeMap;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectFrom;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectFromTypeMap;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectWhere;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectWherePartition;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectWherePartitionTypeMap;
import info.archinnov.achilles.internals.dsl.query.select.AbstractSelectWhereTypeMap;
import info.archinnov.achilles.internals.metamodel.AbstractEntityProperty;
import info.archinnov.achilles.internals.metamodel.functions.FunctionCall;
import info.archinnov.achilles.internals.options.CassandraOptions;
import info.archinnov.achilles.internals.runtime.RuntimeEngine;
import info.archinnov.achilles.internals.sample_classes.dsl.select.TestEntityWithUDTAsClustering;
import info.archinnov.achilles.internals.sample_classes.dsl.select.TestUDTWithNoKeyspace;
import info.archinnov.achilles.type.SchemaNameProvider;
import info.archinnov.achilles.validation.Validator;
import java.lang.Class;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import org.apache.commons.lang3.ArrayUtils;

public final class TestEntityWithUDTAsClustering_Select extends AbstractSelect {
  protected final TestEntityWithUDTAsClustering_AchillesMeta meta;

  protected final Class<TestEntityWithUDTAsClustering> entityClass = TestEntityWithUDTAsClustering.class;

  public TestEntityWithUDTAsClustering_Select(RuntimeEngine rte, TestEntityWithUDTAsClustering_AchillesMeta meta) {
    super(rte);
    this.meta = meta;
  }

  /**
   * Generate a SELECT ... <strong>id</strong> ... */
  public final TestEntityWithUDTAsClustering_Select.Cols id() {
    select.column("id");
    return new TestEntityWithUDTAsClustering_Select.Cols(select);
  }

  /**
   * Generate a SELECT ... <strong>udtlist</strong> ... */
  public final TestEntityWithUDTAsClustering_Select.Cols udtList() {
    select.column("udtlist");
    return new TestEntityWithUDTAsClustering_Select.Cols(select);
  }

  /**
   * Generate a SELECT ... <strong>udtset</strong> ... */
  public final TestEntityWithUDTAsClustering_Select.Cols udtSet() {
    select.column("udtset");
    return new TestEntityWithUDTAsClustering_Select.Cols(select);
  }

  /**
   * Generate a SELECT ... <strong>udtmapkey</strong> ... */
  public final TestEntityWithUDTAsClustering_Select.Cols udtMapKey() {
    select.column("udtmapkey");
    return new TestEntityWithUDTAsClustering_Select.Cols(select);
  }

  /**
   * Generate a SELECT ... <strong>udtmapvalue</strong> ... */
  public final TestEntityWithUDTAsClustering_Select.Cols udtMapValue() {
    select.column("udtmapvalue");
    return new TestEntityWithUDTAsClustering_Select.Cols(select);
  }

  /**
   * Generate a SELECT ... <strong>clust(.?)</strong> ... */
  public final TestEntityWithUDTAsClustering_Select.Clust_UDT clust() {
    return new TestEntityWithUDTAsClustering_Select.Clust_UDT();
  }

  /**
   * Generate a SELECT ... <strong>udt(.?)</strong> ... */
  public final TestEntityWithUDTAsClustering_Select.Udt_UDT udt() {
    return new TestEntityWithUDTAsClustering_Select.Udt_UDT();
  }

  /**
   * Use this method to call a system or user-defined function.<br/>All the system functions are accessible from the <strong>{@link info.archinnov.achilles.generated.function.SystemFunctions}</strong> class<br/>All the user-defined functions and aggregates are accessible from the <strong>{@link info.archinnov.achilles.generated.function.FunctionsRegistry}</strong> class<br/>System and user-defined functions accept only appropriate type. To pass in an entity field as function argument, use the generated <strong>manager.COLUMNS</strong> class which exposes all columns with their appropriate type<br/>Example: <pre class="code"><code class="java">
   *   {@literal @}Table
   *   public class MyEntity {
   *
   *       ...
   *
   *       {@literal @}Column("value_column")
   *       private String value;
   *
   *       {@literal @}Column("list_of_string")
   *       private List<String> strings;
   *
   *       ...
   *
   *   }
   *
   *   {@literal @}FunctionsRegistry
   *   public interface MyFunctions {
   *
   *        String convertListToJson(List<String> strings);
   *
   *   }
   *
   *
   *   ...
   *
   *
   *   manager
   *      .dsl()
   *      .select()
   *      // This call will generate SELECT cast(writetime(value_column) as text) AS writetimeOfValueAsString, ...
   *      .function(SystemFunctions.castAsText(SystemFunctions.writetime(manager.COLUMNS.VALUE)), "writetimeOfValueAsString")
   *      ...
   *
   *   manager
   *      .dsl()
   *      .select()
   *      // This call will generate SELECT convertlisttojson(list_of_string) AS strings_as_json, ...
   *      .function(FunctionsRegistry.convertListToJson(manager.COLUMNS.STRINGS), "strings_as_json")
   *      ...
   *
   * </code></pre>
   * <br/>
   * @param functionCall the function call object
   * @param alias mandatory alias for this function call for easier retrieval from the ResultSet
   * @return a built-in function call passed to the QueryBuilder object
   */
  public final TestEntityWithUDTAsClustering_Select.ColsTM function(final FunctionCall functionCall, final String alias) {
    functionCall.addToSelect(select, alias);
    return new TestEntityWithUDTAsClustering_Select.ColsTM(select);
  }

  /**
   * Generate ... * FROM ... */
  public final TestEntityWithUDTAsClustering_Select.F allColumns_FromBaseTable() {
    final Select.Where where = select.all().from(meta.getKeyspace().orElse("unknown_keyspace_for_" + meta.entityClass.getCanonicalName()), meta.getTableOrViewName()).where();
    return new TestEntityWithUDTAsClustering_Select.F(where, new CassandraOptions());
  }

  /**
   * Generate ... * FROM ... using the given SchemaNameProvider */
  public final TestEntityWithUDTAsClustering_Select.F allColumns_From(final SchemaNameProvider schemaNameProvider) {
    final String currentKeyspace = lookupKeyspace(schemaNameProvider, meta.entityClass);
    final String currentTable = lookupTable(schemaNameProvider, meta.entityClass);
    final Select.Where where = select.all().from(currentKeyspace, currentTable).where();
    return new TestEntityWithUDTAsClustering_Select.F(where, CassandraOptions.withSchemaNameProvider(schemaNameProvider));
  }

  public class Cols extends AbstractSelectColumns {
    public Cols(Select.Selection selection) {
      super(selection);
    }

    /**
     * Generate a SELECT ... <strong>id</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols id() {
      selection.column("id");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtlist</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols udtList() {
      selection.column("udtlist");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtset</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols udtSet() {
      selection.column("udtset");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtmapkey</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols udtMapKey() {
      selection.column("udtmapkey");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtmapvalue</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols udtMapValue() {
      selection.column("udtmapvalue");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>clust(.?)</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols.Clust_UDT clust() {
      return new TestEntityWithUDTAsClustering_Select.Cols.Clust_UDT();
    }

    /**
     * Generate a SELECT ... <strong>udt(.?)</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols.Udt_UDT udt() {
      return new TestEntityWithUDTAsClustering_Select.Cols.Udt_UDT();
    }

    /**
     * Use this method to call a system or user-defined function.<br/>All the system functions are accessible from the <strong>{@link info.archinnov.achilles.generated.function.SystemFunctions}</strong> class<br/>All the user-defined functions and aggregates are accessible from the <strong>{@link info.archinnov.achilles.generated.function.FunctionsRegistry}</strong> class<br/>System and user-defined functions accept only appropriate type. To pass in an entity field as function argument, use the generated <strong>manager.COLUMNS</strong> class which exposes all columns with their appropriate type<br/>Example: <pre class="code"><code class="java">
     *   {@literal @}Table
     *   public class MyEntity {
     *
     *       ...
     *
     *       {@literal @}Column("value_column")
     *       private String value;
     *
     *       {@literal @}Column("list_of_string")
     *       private List<String> strings;
     *
     *       ...
     *
     *   }
     *
     *   {@literal @}FunctionsRegistry
     *   public interface MyFunctions {
     *
     *        String convertListToJson(List<String> strings);
     *
     *   }
     *
     *
     *   ...
     *
     *
     *   manager
     *      .dsl()
     *      .select()
     *      // This call will generate SELECT cast(writetime(value_column) as text) AS writetimeOfValueAsString, ...
     *      .function(SystemFunctions.castAsText(SystemFunctions.writetime(manager.COLUMNS.VALUE)), "writetimeOfValueAsString")
     *      ...
     *
     *   manager
     *      .dsl()
     *      .select()
     *      // This call will generate SELECT convertlisttojson(list_of_string) AS strings_as_json, ...
     *      .function(FunctionsRegistry.convertListToJson(manager.COLUMNS.STRINGS), "strings_as_json")
     *      ...
     *
     * </code></pre>
     * <br/>
     * @param functionCall the function call object
     * @param alias mandatory alias for this function call for easier retrieval from the ResultSet
     * @return a built-in function call passed to the QueryBuilder object
     */
    public final TestEntityWithUDTAsClustering_Select.ColsTM function(final FunctionCall functionCall, final String alias) {
      functionCall.addToSelect(selection, alias);
      return new TestEntityWithUDTAsClustering_Select.ColsTM(select);
    }

    /**
     * Generate a ... <strong>FROM xxx</strong> ...  */
    public final TestEntityWithUDTAsClustering_Select.F fromBaseTable() {
      final Select.Where where = selection.from(meta.getKeyspace().orElse("unknown_keyspace_for_" + meta.entityClass.getCanonicalName()), meta.getTableOrViewName()).where();
      return new TestEntityWithUDTAsClustering_Select.F(where, new CassandraOptions());
    }

    /**
     * Generate a ... <strong>FROM xxx</strong> ... using the given SchemaNameProvider */
    public final TestEntityWithUDTAsClustering_Select.F from(final SchemaNameProvider schemaNameProvider) {
      final String currentKeyspace = lookupKeyspace(schemaNameProvider, meta.entityClass);
      final String currentTable = lookupTable(schemaNameProvider, meta.entityClass);
      final Select.Where where = selection.from(currentKeyspace, currentTable).where();
      return new TestEntityWithUDTAsClustering_Select.F(where, CassandraOptions.withSchemaNameProvider(schemaNameProvider));
    }

    public class Clust_UDT {
      /**
       * Generate a SELECT ... <strong>clust.id</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.Cols id() {
        selection.raw("clust.id");
        return TestEntityWithUDTAsClustering_Select.Cols.this;
      }

      /**
       * Generate a SELECT ... <strong>clust."VALUE"</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.Cols value() {
        selection.raw("clust.\"VALUE\"");
        return TestEntityWithUDTAsClustering_Select.Cols.this;
      }

      /**
       * Generate a SELECT ... <strong>clust</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.Cols allColumns() {
        selection.raw("clust");
        return TestEntityWithUDTAsClustering_Select.Cols.this;
      }
    }

    public class Udt_UDT {
      /**
       * Generate a SELECT ... <strong>udt.id</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.Cols id() {
        selection.raw("udt.id");
        return TestEntityWithUDTAsClustering_Select.Cols.this;
      }

      /**
       * Generate a SELECT ... <strong>udt."VALUE"</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.Cols value() {
        selection.raw("udt.\"VALUE\"");
        return TestEntityWithUDTAsClustering_Select.Cols.this;
      }

      /**
       * Generate a SELECT ... <strong>udt</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.Cols allColumns() {
        selection.raw("udt");
        return TestEntityWithUDTAsClustering_Select.Cols.this;
      }
    }
  }

  public class ColsTM extends AbstractSelectColumnsTypeMap {
    public ColsTM(Select.Selection selection) {
      super(selection);
    }

    /**
     * Generate a SELECT ... <strong>id</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.ColsTM id() {
      selection.column("id");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtlist</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.ColsTM udtList() {
      selection.column("udtlist");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtset</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.ColsTM udtSet() {
      selection.column("udtset");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtmapkey</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.ColsTM udtMapKey() {
      selection.column("udtmapkey");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>udtmapvalue</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.ColsTM udtMapValue() {
      selection.column("udtmapvalue");
      return this;
    }

    /**
     * Generate a SELECT ... <strong>clust(.?)</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.ColsTM.Clust_UDT clust() {
      return new TestEntityWithUDTAsClustering_Select.ColsTM.Clust_UDT();
    }

    /**
     * Generate a SELECT ... <strong>udt(.?)</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.ColsTM.Udt_UDT udt() {
      return new TestEntityWithUDTAsClustering_Select.ColsTM.Udt_UDT();
    }

    /**
     * Use this method to call a system or user-defined function.<br/>All the system functions are accessible from the <strong>{@link info.archinnov.achilles.generated.function.SystemFunctions}</strong> class<br/>All the user-defined functions and aggregates are accessible from the <strong>{@link info.archinnov.achilles.generated.function.FunctionsRegistry}</strong> class<br/>System and user-defined functions accept only appropriate type. To pass in an entity field as function argument, use the generated <strong>manager.COLUMNS</strong> class which exposes all columns with their appropriate type<br/>Example: <pre class="code"><code class="java">
     *   {@literal @}Table
     *   public class MyEntity {
     *
     *       ...
     *
     *       {@literal @}Column("value_column")
     *       private String value;
     *
     *       {@literal @}Column("list_of_string")
     *       private List<String> strings;
     *
     *       ...
     *
     *   }
     *
     *   {@literal @}FunctionsRegistry
     *   public interface MyFunctions {
     *
     *        String convertListToJson(List<String> strings);
     *
     *   }
     *
     *
     *   ...
     *
     *
     *   manager
     *      .dsl()
     *      .select()
     *      // This call will generate SELECT cast(writetime(value_column) as text) AS writetimeOfValueAsString, ...
     *      .function(SystemFunctions.castAsText(SystemFunctions.writetime(manager.COLUMNS.VALUE)), "writetimeOfValueAsString")
     *      ...
     *
     *   manager
     *      .dsl()
     *      .select()
     *      // This call will generate SELECT convertlisttojson(list_of_string) AS strings_as_json, ...
     *      .function(FunctionsRegistry.convertListToJson(manager.COLUMNS.STRINGS), "strings_as_json")
     *      ...
     *
     * </code></pre>
     * <br/>
     * @param functionCall the function call object
     * @param alias mandatory alias for this function call for easier retrieval from the ResultSet
     * @return a built-in function call passed to the QueryBuilder object
     */
    public final TestEntityWithUDTAsClustering_Select.ColsTM function(final FunctionCall functionCall, final String alias) {
      functionCall.addToSelect(selection, alias);
      return this;
    }

    /**
     * Generate a ... <strong>FROM xxx</strong> ...  */
    public final TestEntityWithUDTAsClustering_Select.F_TM fromBaseTable() {
      final Select.Where where = selection.from(meta.getKeyspace().orElse("unknown_keyspace_for_" + meta.entityClass.getCanonicalName()), meta.getTableOrViewName()).where();
      return new TestEntityWithUDTAsClustering_Select.F_TM(where, new CassandraOptions());
    }

    /**
     * Generate a ... <strong>FROM xxx</strong> ... using the given SchemaNameProvider */
    public final TestEntityWithUDTAsClustering_Select.F_TM from(final SchemaNameProvider schemaNameProvider) {
      final String currentKeyspace = lookupKeyspace(schemaNameProvider, meta.entityClass);
      final String currentTable = lookupTable(schemaNameProvider, meta.entityClass);
      final Select.Where where = selection.from(currentKeyspace, currentTable).where();
      return new TestEntityWithUDTAsClustering_Select.F_TM(where, CassandraOptions.withSchemaNameProvider(schemaNameProvider));
    }

    public class Clust_UDT {
      /**
       * Generate a SELECT ... <strong>clust.id</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.ColsTM id() {
        selection.raw("clust.id");
        return TestEntityWithUDTAsClustering_Select.ColsTM.this;
      }

      /**
       * Generate a SELECT ... <strong>clust."VALUE"</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.ColsTM value() {
        selection.raw("clust.\"VALUE\"");
        return TestEntityWithUDTAsClustering_Select.ColsTM.this;
      }

      /**
       * Generate a SELECT ... <strong>clust</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.ColsTM allColumns() {
        selection.raw("clust");
        return TestEntityWithUDTAsClustering_Select.ColsTM.this;
      }
    }

    public class Udt_UDT {
      /**
       * Generate a SELECT ... <strong>udt.id</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.ColsTM id() {
        selection.raw("udt.id");
        return TestEntityWithUDTAsClustering_Select.ColsTM.this;
      }

      /**
       * Generate a SELECT ... <strong>udt."VALUE"</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.ColsTM value() {
        selection.raw("udt.\"VALUE\"");
        return TestEntityWithUDTAsClustering_Select.ColsTM.this;
      }

      /**
       * Generate a SELECT ... <strong>udt</strong> ... */
      public final TestEntityWithUDTAsClustering_Select.ColsTM allColumns() {
        selection.raw("udt");
        return TestEntityWithUDTAsClustering_Select.ColsTM.this;
      }
    }
  }

  public class F extends AbstractSelectFrom {
    F(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    /**
     * Generate a SELECT ... FROM ... <strong>WHERE</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.W_Id where() {
      return new TestEntityWithUDTAsClustering_Select.W_Id(where, cassandraOptions);
    }

    /**
     * Generate a SELECT statement <strong>without</strong> the <strong>WHERE</strong> clause */
    public final TestEntityWithUDTAsClustering_Select.E without_WHERE_Clause() {
      return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
    }
  }

  public class F_TM extends AbstractSelectFromTypeMap {
    F_TM(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    /**
     * Generate a SELECT ... FROM ... <strong>WHERE</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.W_TM_Id where() {
      return new TestEntityWithUDTAsClustering_Select.W_TM_Id(where, cassandraOptions);
    }

    /**
     * Generate a SELECT statement <strong>without</strong> the <strong>WHERE</strong> clause */
    public final TestEntityWithUDTAsClustering_Select.E_TM without_WHERE_Clause() {
      return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
    }
  }

  public class Clust_UDT {
    /**
     * Generate a SELECT ... <strong>clust.id</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols id() {
      select.raw("clust.id");
      return new TestEntityWithUDTAsClustering_Select.Cols(select);
    }

    /**
     * Generate a SELECT ... <strong>clust."VALUE"</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols value() {
      select.raw("clust.\"VALUE\"");
      return new TestEntityWithUDTAsClustering_Select.Cols(select);
    }

    /**
     * Generate a SELECT ... <strong>clust</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols allColumns() {
      select.raw("clust");
      return new TestEntityWithUDTAsClustering_Select.Cols(select);
    }
  }

  public class Udt_UDT {
    /**
     * Generate a SELECT ... <strong>udt.id</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols id() {
      select.raw("udt.id");
      return new TestEntityWithUDTAsClustering_Select.Cols(select);
    }

    /**
     * Generate a SELECT ... <strong>udt."VALUE"</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols value() {
      select.raw("udt.\"VALUE\"");
      return new TestEntityWithUDTAsClustering_Select.Cols(select);
    }

    /**
     * Generate a SELECT ... <strong>udt</strong> ... */
    public final TestEntityWithUDTAsClustering_Select.Cols allColumns() {
      select.raw("udt");
      return new TestEntityWithUDTAsClustering_Select.Cols(select);
    }
  }

  public final class W_Id extends AbstractSelectWherePartition {
    public W_Id(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    public final TestEntityWithUDTAsClustering_Select.W_Id.Relation id() {
      return new TestEntityWithUDTAsClustering_Select.W_Id.Relation();
    }

    public final TestEntityWithUDTAsClustering_Select.W_Id.Token tokenValueOf_id() {
      return new TestEntityWithUDTAsClustering_Select.W_Id.Token();
    }

    public final class Relation {
      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>id = ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.W_Clust Eq(Long id) {
        where.and(QueryBuilder.eq("id", QueryBuilder.bindMarker("id")));
        boundValues.add(id);
        encodedValues.add(meta.id.encodeFromJava(id, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.W_Clust(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>id IN ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.W_Clust IN(Long... id) {
        Validator.validateTrue(ArrayUtils.isNotEmpty(id), "Varargs for field '%s' should not be null/empty", "id");
        where.and(QueryBuilder.in("id",QueryBuilder.bindMarker("id")));
        final List<Object> varargs = Arrays.<Object>asList((Object[])id);
        final List<Object> encodedVarargs = Arrays.<Long>stream((Long[])id).map(x -> meta.id.encodeFromJava(x, Optional.of(cassandraOptions))).collect(Collectors.toList());
        boundValues.add(varargs);
        encodedValues.add(encodedVarargs);
        return new TestEntityWithUDTAsClustering_Select.W_Clust(where, cassandraOptions);
      }
    }

    public final class Token {
      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) = ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Eq(Long tokenValue) {
        where.and(QueryBuilder.eq("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) > ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gt(Long tokenValue) {
        where.and(QueryBuilder.gt("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) >= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gte(Long tokenValue) {
        where.and(QueryBuilder.gte("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Lt(Long tokenValue) {
        where.and(QueryBuilder.lt("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Lte(Long tokenValue) {
        where.and(QueryBuilder.lte("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) > ? AND token(id) < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gt_And_Lt(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gt("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lt("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) > ? AND token(id) <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gt_And_Lte(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gt("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lte("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) >= ? AND token(id) < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gte_And_Lt(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gte("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lt("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) >= ? AND token(id) <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gte_And_Lte(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gte("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lte("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }
    }
  }

  public final class W_Clust extends AbstractSelectWhere<TestEntityWithUDTAsClustering_Select.W_Clust, TestEntityWithUDTAsClustering> {
    public W_Clust(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    @Override
    protected final TestEntityWithUDTAsClustering_Select.W_Clust getThis() {
      return this;
    }

    @Override
    protected final AbstractEntityProperty<TestEntityWithUDTAsClustering> getMetaInternal() {
      return meta;
    }

    @Override
    protected final Class<TestEntityWithUDTAsClustering> getEntityClass() {
      return entityClass;
    }

    @Override
    protected final RuntimeEngine getRte() {
      return rte;
    }

    @Override
    protected final CassandraOptions getOptions() {
      return cassandraOptions;
    }

    @Override
    protected final List<Object> getBoundValuesInternal() {
      return boundValues;
    }

    @Override
    protected final List<Object> getEncodedValuesInternal() {
      return encodedValues;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>LIMIT :limit</strong> */
    public final TestEntityWithUDTAsClustering_Select.W_Clust limit(final Integer limit) {
      where.limit(QueryBuilder.bindMarker("lim"));
      boundValues.add(limit);
      encodedValues.add(limit);
      return this;
    }

    public final TestEntityWithUDTAsClustering_Select.W_Clust.Relation clust() {
      return new TestEntityWithUDTAsClustering_Select.W_Clust.Relation();
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust ASC</strong> */
    public final TestEntityWithUDTAsClustering_Select.W_Clust orderByClustAscending() {
      where.orderBy(QueryBuilder.asc("clust"));
      return this;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust DESC</strong> */
    public final TestEntityWithUDTAsClustering_Select.W_Clust orderByClustDescending() {
      where.orderBy(QueryBuilder.desc("clust"));
      return this;
    }

    public final class Relation {
      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust = ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Eq(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.eq("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust IN ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E IN(TestUDTWithNoKeyspace... clust) {
        Validator.validateTrue(ArrayUtils.isNotEmpty(clust), "Varargs for field '%s' should not be null/empty", "clust");
        where.and(QueryBuilder.in("clust",QueryBuilder.bindMarker("clust")));
        final List<Object> varargs = Arrays.<Object>asList((Object[])clust);
        final List<Object> encodedVarargs = Arrays.<TestUDTWithNoKeyspace>stream((TestUDTWithNoKeyspace[])clust).map(x -> meta.clust.encodeFromJava(x, Optional.of(cassandraOptions))).collect(Collectors.toList());
        boundValues.add(varargs);
        encodedValues.add(encodedVarargs);
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust > ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gt(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.gt("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust >= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gte(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.gte("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Lt(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.lt("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Lte(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.lte("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust > ? AND clust < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gt_And_Lt(TestUDTWithNoKeyspace clust_Gt, TestUDTWithNoKeyspace clust_Lt) {
        where.and(QueryBuilder.gt("clust",QueryBuilder.bindMarker("clust_Lt")));
        where.and(QueryBuilder.lt("clust",QueryBuilder.bindMarker("clust_Lt")));
        boundValues.add(clust_Gt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gt, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lt, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust > ? AND clust <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gt_And_Lte(TestUDTWithNoKeyspace clust_Gt, TestUDTWithNoKeyspace clust_Lte) {
        where.and(QueryBuilder.gt("clust",QueryBuilder.bindMarker("clust_Lte")));
        where.and(QueryBuilder.lte("clust",QueryBuilder.bindMarker("clust_Lte")));
        boundValues.add(clust_Gt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gt, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lte, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust >= ? AND clust < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gte_And_Lt(TestUDTWithNoKeyspace clust_Gte, TestUDTWithNoKeyspace clust_Lt) {
        where.and(QueryBuilder.gte("clust",QueryBuilder.bindMarker("clust_Lt")));
        where.and(QueryBuilder.lt("clust",QueryBuilder.bindMarker("clust_Lt")));
        boundValues.add(clust_Gte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gte, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lt, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust >= ? AND clust <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E Gte_And_Lte(TestUDTWithNoKeyspace clust_Gte, TestUDTWithNoKeyspace clust_Lte) {
        where.and(QueryBuilder.gte("clust",QueryBuilder.bindMarker("clust_Lte")));
        where.and(QueryBuilder.lte("clust",QueryBuilder.bindMarker("clust_Lte")));
        boundValues.add(clust_Gte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gte, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lte, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E(where, cassandraOptions);
      }
    }
  }

  public final class E extends AbstractSelectWhere<TestEntityWithUDTAsClustering_Select.E, TestEntityWithUDTAsClustering> {
    public E(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    @Override
    protected final Class<TestEntityWithUDTAsClustering> getEntityClass() {
      return entityClass;
    }

    @Override
    protected final AbstractEntityProperty<TestEntityWithUDTAsClustering> getMetaInternal() {
      return meta;
    }

    @Override
    protected final RuntimeEngine getRte() {
      return rte;
    }

    @Override
    protected final CassandraOptions getOptions() {
      return cassandraOptions;
    }

    @Override
    protected final List<Object> getBoundValuesInternal() {
      return boundValues;
    }

    @Override
    protected final List<Object> getEncodedValuesInternal() {
      return encodedValues;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>LIMIT :limit</strong> */
    public final TestEntityWithUDTAsClustering_Select.E limit(final Integer limit) {
      where.limit(QueryBuilder.bindMarker("lim"));
      boundValues.add(limit);
      encodedValues.add(limit);
      return this;
    }

    @Override
    protected final TestEntityWithUDTAsClustering_Select.E getThis() {
      return this;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust ASC</strong> */
    public final TestEntityWithUDTAsClustering_Select.E orderByClustAscending() {
      where.orderBy(QueryBuilder.asc("clust"));
      return this;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust DESC</strong> */
    public final TestEntityWithUDTAsClustering_Select.E orderByClustDescending() {
      where.orderBy(QueryBuilder.desc("clust"));
      return this;
    }
  }

  public final class W_TM_Id extends AbstractSelectWherePartitionTypeMap {
    public W_TM_Id(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    public final TestEntityWithUDTAsClustering_Select.W_TM_Id.Relation id() {
      return new TestEntityWithUDTAsClustering_Select.W_TM_Id.Relation();
    }

    public final TestEntityWithUDTAsClustering_Select.W_TM_Id.Token tokenValueOf_id() {
      return new TestEntityWithUDTAsClustering_Select.W_TM_Id.Token();
    }

    public final class Relation {
      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>id = ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.W_TM_Clust Eq(Long id) {
        where.and(QueryBuilder.eq("id", QueryBuilder.bindMarker("id")));
        boundValues.add(id);
        encodedValues.add(meta.id.encodeFromJava(id, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.W_TM_Clust(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>id IN ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.W_TM_Clust IN(Long... id) {
        Validator.validateTrue(ArrayUtils.isNotEmpty(id), "Varargs for field '%s' should not be null/empty", "id");
        where.and(QueryBuilder.in("id",QueryBuilder.bindMarker("id")));
        final List<Object> varargs = Arrays.<Object>asList((Object[])id);
        final List<Object> encodedVarargs = Arrays.<Long>stream((Long[])id).map(x -> meta.id.encodeFromJava(x, Optional.of(cassandraOptions))).collect(Collectors.toList());
        boundValues.add(varargs);
        encodedValues.add(encodedVarargs);
        return new TestEntityWithUDTAsClustering_Select.W_TM_Clust(where, cassandraOptions);
      }
    }

    public final class Token {
      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) = ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Eq(Long tokenValue) {
        where.and(QueryBuilder.eq("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) > ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gt(Long tokenValue) {
        where.and(QueryBuilder.gt("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) >= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gte(Long tokenValue) {
        where.and(QueryBuilder.gte("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Lt(Long tokenValue) {
        where.and(QueryBuilder.lt("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Lte(Long tokenValue) {
        where.and(QueryBuilder.lte("token(id)", QueryBuilder.bindMarker("tokenValue")));
        boundValues.add(tokenValue);
        encodedValues.add(tokenValue);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) > ? AND token(id) < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gt_And_Lt(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gt("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lt("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) > ? AND token(id) <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gt_And_Lte(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gt("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lte("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) >= ? AND token(id) < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gte_And_Lt(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gte("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lt("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>token(id) >= ? AND token(id) <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gte_And_Lte(Long tokenValue1, Long tokenValue2) {
        where.and(QueryBuilder.gte("token(id)",QueryBuilder.bindMarker("tokenValue1")));
        where.and(QueryBuilder.lte("token(id)",QueryBuilder.bindMarker("tokenValue2")));
        boundValues.add(tokenValue1);
        encodedValues.add(tokenValue1);
        boundValues.add(tokenValue2);
        encodedValues.add(tokenValue2);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }
    }
  }

  public final class W_TM_Clust extends AbstractSelectWhereTypeMap<TestEntityWithUDTAsClustering_Select.W_TM_Clust, TestEntityWithUDTAsClustering> {
    public W_TM_Clust(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    @Override
    protected final TestEntityWithUDTAsClustering_Select.W_TM_Clust getThis() {
      return this;
    }

    @Override
    protected final AbstractEntityProperty<TestEntityWithUDTAsClustering> getMetaInternal() {
      return meta;
    }

    @Override
    protected final Class<TestEntityWithUDTAsClustering> getEntityClass() {
      return entityClass;
    }

    @Override
    protected final RuntimeEngine getRte() {
      return rte;
    }

    @Override
    protected final CassandraOptions getOptions() {
      return cassandraOptions;
    }

    @Override
    protected final List<Object> getBoundValuesInternal() {
      return boundValues;
    }

    @Override
    protected final List<Object> getEncodedValuesInternal() {
      return encodedValues;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>LIMIT :limit</strong> */
    public final TestEntityWithUDTAsClustering_Select.W_TM_Clust limit(final Integer limit) {
      where.limit(QueryBuilder.bindMarker("lim"));
      boundValues.add(limit);
      encodedValues.add(limit);
      return this;
    }

    public final TestEntityWithUDTAsClustering_Select.W_TM_Clust.Relation clust() {
      return new TestEntityWithUDTAsClustering_Select.W_TM_Clust.Relation();
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust ASC</strong> */
    public final TestEntityWithUDTAsClustering_Select.W_TM_Clust orderByClustAscending() {
      where.orderBy(QueryBuilder.asc("clust"));
      return this;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust DESC</strong> */
    public final TestEntityWithUDTAsClustering_Select.W_TM_Clust orderByClustDescending() {
      where.orderBy(QueryBuilder.desc("clust"));
      return this;
    }

    public final class Relation {
      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust = ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Eq(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.eq("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust IN ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM IN(TestUDTWithNoKeyspace... clust) {
        Validator.validateTrue(ArrayUtils.isNotEmpty(clust), "Varargs for field '%s' should not be null/empty", "clust");
        where.and(QueryBuilder.in("clust",QueryBuilder.bindMarker("clust")));
        final List<Object> varargs = Arrays.<Object>asList((Object[])clust);
        final List<Object> encodedVarargs = Arrays.<TestUDTWithNoKeyspace>stream((TestUDTWithNoKeyspace[])clust).map(x -> meta.clust.encodeFromJava(x, Optional.of(cassandraOptions))).collect(Collectors.toList());
        boundValues.add(varargs);
        encodedValues.add(encodedVarargs);
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust > ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gt(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.gt("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust >= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gte(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.gte("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Lt(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.lt("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Lte(TestUDTWithNoKeyspace clust) {
        where.and(QueryBuilder.lte("clust", QueryBuilder.bindMarker("clust")));
        boundValues.add(clust);
        encodedValues.add(meta.clust.encodeFromJava(clust, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust > ? AND clust < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gt_And_Lt(TestUDTWithNoKeyspace clust_Gt, TestUDTWithNoKeyspace clust_Lt) {
        where.and(QueryBuilder.gt("clust",QueryBuilder.bindMarker("clust_Lt")));
        where.and(QueryBuilder.lt("clust",QueryBuilder.bindMarker("clust_Lt")));
        boundValues.add(clust_Gt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gt, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lt, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust > ? AND clust <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gt_And_Lte(TestUDTWithNoKeyspace clust_Gt, TestUDTWithNoKeyspace clust_Lte) {
        where.and(QueryBuilder.gt("clust",QueryBuilder.bindMarker("clust_Lte")));
        where.and(QueryBuilder.lte("clust",QueryBuilder.bindMarker("clust_Lte")));
        boundValues.add(clust_Gt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gt, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lte, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust >= ? AND clust < ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gte_And_Lt(TestUDTWithNoKeyspace clust_Gte, TestUDTWithNoKeyspace clust_Lt) {
        where.and(QueryBuilder.gte("clust",QueryBuilder.bindMarker("clust_Lt")));
        where.and(QueryBuilder.lt("clust",QueryBuilder.bindMarker("clust_Lt")));
        boundValues.add(clust_Gte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gte, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lt);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lt, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }

      /**
       * Generate a SELECT ... FROM ... WHERE ... <strong>clust >= ? AND clust <= ?</strong> */
      @SuppressWarnings("static-access")
      public final TestEntityWithUDTAsClustering_Select.E_TM Gte_And_Lte(TestUDTWithNoKeyspace clust_Gte, TestUDTWithNoKeyspace clust_Lte) {
        where.and(QueryBuilder.gte("clust",QueryBuilder.bindMarker("clust_Lte")));
        where.and(QueryBuilder.lte("clust",QueryBuilder.bindMarker("clust_Lte")));
        boundValues.add(clust_Gte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Gte, Optional.of(cassandraOptions)));
        boundValues.add(clust_Lte);
        encodedValues.add(meta.clust.encodeFromJava(clust_Lte, Optional.of(cassandraOptions)));
        return new TestEntityWithUDTAsClustering_Select.E_TM(where, cassandraOptions);
      }
    }
  }

  public final class E_TM extends AbstractSelectWhereTypeMap<TestEntityWithUDTAsClustering_Select.E_TM, TestEntityWithUDTAsClustering> {
    public E_TM(Select.Where where, CassandraOptions cassandraOptions) {
      super(where, cassandraOptions);
    }

    @Override
    protected final Class<TestEntityWithUDTAsClustering> getEntityClass() {
      return entityClass;
    }

    @Override
    protected final AbstractEntityProperty<TestEntityWithUDTAsClustering> getMetaInternal() {
      return meta;
    }

    @Override
    protected final RuntimeEngine getRte() {
      return rte;
    }

    @Override
    protected final CassandraOptions getOptions() {
      return cassandraOptions;
    }

    @Override
    protected final List<Object> getBoundValuesInternal() {
      return boundValues;
    }

    @Override
    protected final List<Object> getEncodedValuesInternal() {
      return encodedValues;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>LIMIT :limit</strong> */
    public final TestEntityWithUDTAsClustering_Select.E_TM limit(final Integer limit) {
      where.limit(QueryBuilder.bindMarker("lim"));
      boundValues.add(limit);
      encodedValues.add(limit);
      return this;
    }

    @Override
    protected final TestEntityWithUDTAsClustering_Select.E_TM getThis() {
      return this;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust ASC</strong> */
    public final TestEntityWithUDTAsClustering_Select.E_TM orderByClustAscending() {
      where.orderBy(QueryBuilder.asc("clust"));
      return this;
    }

    /**
     * Generate a SELECT ... FROM ... WHERE ... <strong>ORDER BY clust DESC</strong> */
    public final TestEntityWithUDTAsClustering_Select.E_TM orderByClustDescending() {
      where.orderBy(QueryBuilder.desc("clust"));
      return this;
    }
  }
}